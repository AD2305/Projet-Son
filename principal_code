#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>

// üéõÔ∏è Objets audio
AudioInputI2S in;             // Entr√©e micro
AudioRecordQueue recorder;    // Enregistreur

AudioPlaySdWav           player1;
AudioPlaySdWav           player2;
AudioPlaySdWav           player3;
AudioPlaySdWav           player4;

// üéõ Effets audio (1 par player)
AudioEffectReverb        reverb1;
AudioEffectReverb        reverb2;
AudioEffectReverb        reverb3;
AudioEffectReverb        reverb4;

AudioEffectDelay         delay1;
AudioEffectDelay         delay2;
AudioEffectDelay         delay3;
AudioEffectDelay         delay4;

// üéö Mixers individuels pour chaque player
AudioMixer4              mixer1;

AudioOutputI2S audioOutput;      // Sortie audio
AudioControlSGTL5000 audioShield;

// üéö Assignation des connexions audio
AudioConnection patchCord1(player1, reverb1);
AudioConnection patchCord2(reverb1, 0, delay1, 0);
AudioConnection patchCord3(delay1, 0, mixer1, 0);

AudioConnection patchCord4(player2, reverb2);
AudioConnection patchCord5(reverb2, 0, delay2, 0);
AudioConnection patchCord6(delay2, 0, mixer2, 0);

AudioConnection patchCord7(player3, reverb3);
AudioConnection patchCord8(reverb3, 0, delay3, 0);
AudioConnection patchCord9(delay3, 0, mixer3, 0);

AudioConnection patchCord10(player4, reverb4);
AudioConnection patchCord11(reverb4, 0, delay4, 0);
AudioConnection patchCord12(delay4, 0, mixer4, 0);

AudioConnection patchCord16(player1, mixer1, 0);
AudioConnection patchCord17(player2, mixer1, 1);
AudioConnection patchCord18(player3, mixer1, 2);
AudioConnection patchCord19(player4, mixer1, 3);

// üîä Chaque player envoie du son vers les deux canaux (st√©r√©o)
AudioConnection patchCord13(mixer1, 0, audioOutput, 0);
AudioConnection patchCord14(mixer1, 0, audioOutput, 1);


// Potentiom√®tres
const int potReverb = A0;  // Contr√¥le la r√©verb√©ration
const int potDelay = A1;   // Contr√¥le l'√©cho
const int potVolume = A2;  // Contr√¥le le volume principal

// üõ†Ô∏è Boutons
const int button1 = 1;  // Joue le premier fichier
const int button2 = 2;  // Joue le deuxi√®me fichier
const int button3 = 3;  
const int button4 = 4;  
const int stopButton = 5; // Stoppe tout
const int recordButton = 0; // Enregistre depuis le micro

// Variables de contr√¥le
int selectedMemory = 0;
const int recordDuration = 5;
bool isRecording = false;
int mixage[4] = {0, 0, 0, 0};

void setup() {
    Serial.begin(9600);
    AudioMemory(40);

    // üîä Initialisation de la carte son
    audioShield.enable();
    audioShield.inputSelect(AUDIO_INPUT_MIC);
    audioShield.micGain(10);
    audioShield.volume(0.8);



    // Initialisation de la carte SD
    if (!SD.begin(BUILTIN_SDCARD)) {
        Serial.println("Erreur : carte SD non d√©tect√©e !");
        return;
    }

    // Configuration des boutons
    pinMode(button1, INPUT_PULLUP);
    pinMode(button2, INPUT_PULLUP);
    pinMode(button3, INPUT_PULLUP);
    pinMode(button4, INPUT_PULLUP);
    pinMode(stopButton, INPUT_PULLUP);
    pinMode(recordButton, INPUT_PULLUP);

    // R√©glage initial des effets
    reverb1.reverbTime(1.5);  // R√©verb√©ration (1.5 sec)
    delay1.delay(0, 250);      // √âcho de 250 ms
    // Initialisation des mixeurs (volume √† 80% au d√©part)
    mixer1.gain(0, 0.8);
}



void loop() {
    // Ajustement des effets avec les potentiom√®tres
    float reverbLevel = map(analogRead(potReverb), 0, 1023, 0, 3000) / 1000.0; // 0 √† 3 sec
    float delayLevel = map(analogRead(potDelay), 0, 1023, 50, 500); // 50 √† 500 ms
    float volumeLevel = map(analogRead(potVolume), 0, 1023, 0, 100) / 100.0; // 0 √† 1.0

    reverb1.reverbTime(reverbLevel);
    delay1.delay(0, delayLevel);
    audioShield.volume(volumeLevel);

    // Lecture des fichiers audio
    if (digitalRead(button1) == LOW) {
        Serial.println("Lecture : sound1.wav ");
        player1.play("sound1.wav");
        selectedMemory = 1;
        StopSounds(selectedMemory);
        Serial.println("M√©moire 1 s√©lectionn√©e");
        resetMixage(mixage,4,selectedMemory);
        mixage[selectedMemory] += 1 ;
        if (mixage[selectedMemory] % 2 == 0){
            selectedMemory = 5 ;
        }
    }

    if (digitalRead(button2) == LOW && !player2.isPlaying()) {
        Serial.println("Lecture : sound2.wav ");
        player2.play("sound2.wav");
        selectedMemory = 2;
        StopSounds(selectedMemory);
        Serial.println("M√©moire 2 s√©lectionn√©e");
        resetMixage(mixage,4,selectedMemory);
        mixage[selectedMemory] += 1 ;
        if (mixage[selectedMemory] % 2 == 0){
            selectedMemory = 5 ;
        }
    }

    if (digitalRead(button3) == LOW && !player3.isPlaying()) {
        Serial.println("Lecture : sound3.wav ");
        player3.play("sound3.wav");
        selectedMemory = 3;
        StopSounds(selectedMemory);
        Serial.println("M√©moire 3 s√©lectionn√©e");
        resetMixage(mixage,4,selectedMemory);
        mixage[selectedMemory] += 1 ;
        if (mixage[selectedMemory] % 2 == 0){
            selectedMemory = 5 ;
        }
    }

    if (digitalRead(button4) == LOW && !player4.isPlaying()) {
        Serial.println("Lecture : sound4.wav ");
        player4.play("sound4.wav");
        selectedMemory = 4;
        StopSounds(selectedMemory);
        Serial.println("M√©moire 4 s√©lectionn√©e");
        resetMixage(mixage,4,selectedMemory);
        mixage[selectedMemory] += 1 ;
        if (mixage[selectedMemory] % 2 == 0){
            selectedMemory = 5 ;
        }
    }

    // Arr√™t des sons
    if (digitalRead(stopButton) == LOW) {

        if (player4.isPlaying()){

        player1.stop();
        player2.stop();
        player3.stop();
        player4.stop();
        Serial.println("Arr√™t les sons.");
        delay(300);

        }else{

        player1.play("sound1.wav");
        player2.play("sound2.wav");
        player3.play("sound3.wav");
        player4.play("sound4.wav");
        Serial.println("Reprends les sons.");
        delay(300);

        }
    }

    //  Enregistrement du micro
    if (digitalRead(recordButton) == LOW && !isRecording) {
        Serial.println("D√©but enregistrement...");
        startRecording();
        delay(300);
    }

    if (isRecording) {
        recordAudio(selectedMemory);
    }
    if (selectedMemory == 5){

        player1.play("sound1.wav");
        player2.play("sound2.wav");
        player3.play("sound3.wav");
        player4.play("sound4.wav");
        Serial.println("Reprends les sons.");
        delay(300);

    }
    setReverb();  
    setDelay();   
    setVolume();
}

//  Fonction pour d√©marrer l'enregistrement
void startRecording() {
    isRecording = true;
    recorder.begin();
}

// Fonction pour enregistrer depuis le micro
void recordAudio(int numeropiste) {

    //anais
    }
}

void resetMixage(int mixage[], int taille, int index) {
    for (int i = 0; i < taille; i++) {
        mixage[i] = (i == index) ? 1 : 0;
    }
}

void StopSounds(int number) {
    if (number >= 1 && number <= 4) {
        if (number != 1) player1.stop();
        if (number != 2) player2.stop();
        if (number != 3) player3.stop();
        if (number != 4) player4.stop();
    }
    Serial.print("Arr√™t de tous les sons sauf la piste ");
    Serial.println(number);
}

// üìå S√©lection du Player actif (via un potentiom√®tre)
int getSelectedPlayer() {
  return selectedMemory;                  
}

// üéõ Appliquer la r√©verb√©ration au player s√©lectionn√©
void setReverb() {
  int playerNumber = getSelectedPlayer();
  float reverbLevel = analogRead(potReverb) / 1023.0 * 4.0;

  switch (playerNumber) {
    case 1: reverb1.reverbTime(reverbLevel); break;
    case 2: reverb2.reverbTime(reverbLevel); break;
    case 3: reverb3.reverbTime(reverbLevel); break;
    case 4: reverb4.reverbTime(reverbLevel); break;
  }
}

// ‚è≥ Appliquer l'√©cho (delay) au player s√©lectionn√©
void setDelay() {
  int playerNumber = getSelectedPlayer();
  float delayLevel = analogRead(potDelay) / 1023.0 * 500;

  switch (playerNumber) {
    case 1: delay1.delay(0, delayLevel); break;
    case 2: delay2.delay(0, delayLevel); break;
    case 3: delay3.delay(0, delayLevel); break;
    case 4: delay4.delay(0, delayLevel); break;
  }
}

// üîä Ajuster le volume du player s√©lectionn√©
void setVolume() {
  int playerNumber = getSelectedPlayer();
  float volumeLevel = analogRead(potVolume) / 1023.0;

  switch (playerNumber) {
    case 1: mixer1.gain(playerNumber - 1 , volumeLevel); break;
    case 2: mixer2.gain(playerNumber - 1, volumeLevel); break;
    case 3: mixer3.gain(playerNumber - 1, volumeLevel); break;
    case 4: mixer4.gain(playerNumber - 1, volumeLevel); break;
  }
}



/*
AudioPlaySdWav playWav1; 
AudioPlaySdWav playWav2; 
AudioPlaySdWav playWav3;
AudioPlaySdWav playWav4; 
AudioMixer4 mixer; 
AudioControlSGTL5000 audioshield;
AudioOutputI2S out;

AudioConnection patchCord1(playWav1, 0, mixer, 0);
AudioConnection patchCord2(playWav2, 0, mixer, 1);
AudioConnection patchCord3(playWav3, 0, mixer, 2);
AudioConnection patchCord4(playWav4, 0, mixer, 3);
AudioConnection patchCord5(mixer, 0, out, 0);
AudioConnection patchCord6(mixer, 0, out, 1);



#define SDCARD_MOSI_PIN  11   
#define SDCARD_SCK_PIN   13  

void setup() {
    Serial.begin(9600);
    AudioMemory(80); // Allouer de la m√©moire audio

    audioshield.enable();
    audioshield.volume(0.4); 

    // Initialize the SD card
    SPI.setMOSI(SDCARD_MOSI_PIN);
    SPI.setSCK(SDCARD_SCK_PIN);
    if (!(SD.begin())) {
      
      while (1) {
        Serial.println("Unable to access the SD card");
        delay(500);
      }
    }

    // D√©marrage des pistes audio
    playWav1.play("SDTEST1.WAV");
    delay(10); 
    playWav2.play("SDTEST2.WAV");
    delay(10); 
    playWav3.play("SDTEST3.WAV");
    delay(10); 
    playWav4.play("SDTEST4.WAV");
    

    mixer.gain(0, 0.4); 
    mixer.gain(1, 0.4); 
    mixer.gain(2, 0.4); 
    mixer.gain(3, 0.4); 
    
    
}

void loop() {

}*/
